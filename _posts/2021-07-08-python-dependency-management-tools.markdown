---
layout: post
title:  Управление зависимостями Python в 2021
date:   2021-07-08 10:00:00 +0300
categories: python
---

Современный Python имеет множество пакетов, помогающих разработчику в решении задач, а также [большое количество инструментов](https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe), которые с этими пакетами работают. В этом изобилии легко запутаться, поэтому давайте попробуем разобраться, что и для чего нужно.

<p align="center"><img src="https://imgs.xkcd.com/comics/standards.png" alt="Создаем очередной менеджер зависимостей"></p>

<!--more-->

### Виртуальное окружение
Представим ситуацию, когда у вас есть два проекта, внутри которых необходимо использовать pytest. В одном из них вам нужен pytest версии 3.x, а в другой - pytest 6.x. Между собой они не имеют обратной совместимости. Глобально интерпретатор в состоянии иметь только одну версию пакета. Как быть в данном случае? Решить эту проблему помогает такой инструмент, как виртуальное окружение. Виртуальное окружение - это изолированная копия Python, которая не видит пакеты, доступные системному интерпретатору, и наоборот.

Как создать виртуальное окружение? Начиная с версии Python 3.3 в стандартной библиотеке есть модуль [venv](https://docs.python.org/3/library/venv.html). Команда
```bash
python -m venv path/to/your-venv
```
создает виртуальное окружение `your-venv` по указаннному `path/to/` пути.
После создания окружения его нужно активировать, чтобы использовать не глобальный системный интерпретатор, а тот, что внутри окружения.
Для Linux и macOS:
```bash
source venv-name/bin/activate
``` 
Для Windows
```PowerShell
venv-name/Scripts/activate.bat
```
В окне терминала должна была появиться приписка об используемом виртуальном окружении. Теперь у вас есть изолированная Python среда, в которую вы можете ставить любые интересующие вас пакеты, не боясь создать коллизий и нарушить работу остальных Python проектов.

До появления venv для создания окружения использовался пакет [virtualenv](https://virtualenv.pypa.io/en/latest/). Он крайне популярен и сейчас, многие системы управления зависимостями используют его. Если вы хотите использовать virtualenv вместо venv, его нужно сначала установить. Делается это командой:
```bash
pip install virtualenv
```
После того, как пакет установлен, можно создавать виртуальные окружения, с помощью команды:
```bash
python -m virtualenv path/to/your-venv
```

В чем же разница между venv и virtualenv, ведь на первый взгяд они делают одно и то же? venv по сути можно назвать подмножеством пакета virtualenv, его сокращенной версией. По [информации из официальной документации](https://virtualenv.pypa.io/en/stable/), venv имеет ряд недостатков по сравнению с virtualenv:
1. Он медленнее, так как virtualenv использует [метод app-data seed](https://virtualenv.pypa.io/en/latest/user_guide.html#seeders) (единожды при первом использовании создает пакеты pip, setuptools, wheel, а при последующих вызовах просто копирует или линкует их)
2. Не расширяем, не имеет богатого API
3. Создает окружение только для своей версии Python
4. Обновляется только вместе с Python интерпретатором, в том время как virtualenv обновляется через pip

В целом, эти минусы не критичные, поэтому если вы по какой-то причине не хотите ставить сторонний пакет (например, на удаленной машине сборки и развертывания), можно легко обойтись встроенным в стандартную библиотеку модулем venv. Однако, большинство систем управления зависимостями (если не все, кроме pip), имееют у себя в своих зависимостях virtualenv, поэтому при их использовании он у вас в системе все равно появится.

Теперь давайте рассмотрим подробнее саму установку пакетов в Python.


### [pip](https://pip.pypa.io/en/stable/)
Package Installer for Python - это базовый инструмент взаимодействия с пакетами в Python. С его помощью можно устанавливать конкретные версии пакетов. По умолчанию он ищет их в [PyPI (Python Package Index)](https://pypi.org/), но с помощью различных опций команд (`--index-url=URL`, `--trusted-host=HOST`) позволяет выполнить поиск и в других хранилищах.
Команда `pip install package-name` попытается найти пакет package-name в PyPI, и если обнаружит его, установит самую последнюю версию и связанные с ней зависимости. 
Чтобы каждый раз при переносе проекта на другую машину заново не искать зависимости вручную, pip позволяет фиксировать их. Файл, в котором фиксируются зависимости по умолчанию принято называть requirements.txt. Фиксация происходит с помощью команды `freeze`:
```bash
pip freeze > requirements.txt
```
Установить зафиксированые зависимости можно с помощью опции `-r` команды `install`:
```bash
pip install -r requirements.txt
```

Работа с requirements.txt обычно имеет два подхода:
1. Фиксация только верхнеуровневых пакетов
2. Фиксация верхнеуровневых пакетов и всех зависимостей

Однако оба подхода имееют под собой набор недостатков. 

Метод 1 - когда зафиксированы только верхнеуровневые пакеты - не может гарантировать, что сборка на другом окружении будет в точности такой же, как у вас сейчас. Например, вы работаете над Python проектом, который использует [Flask](https://palletsprojects.com/p/flask/). Вы включаете пакет в requirements.txt, чтобы остальные разработчики или система автоматизации сборки могли запустить ваш проект. 
```bash
flask
```
Локально все запускается, как задумано, и после работ над проектом вы решаете опубликовать изменения на production окружении. Если пакет зафиксирован без указания версии, то pip по умолчанию скачивает самую последнюю. Но в ней может появится изменение, не имеющее обратной совместимости с вашим кодом. Можно зафиксировать версию пакета, указав конкретную:
```bash
flask==1.1.2
```
Однако у Flask есть и свои зависимости, которые, как и у многих других пакетов, часто тоже не зафиксированы на конкретные версии, например `Flask==1.1.2` может иметь в зависимостях `Werkzeug>=0.15.5`, а значит поставится тоже самая последняя версия, в которой, опять же, может появиться функционал, нарушающий работу приложения. 

Метод 2 - когда зафиксированы все пакеты и их зависимости - является общепринятой практикой. Но и он не без недостатков. Обновить все пакеты до последних версий не выйдет, [такой команды просто нет](https://stackoverflow.com/questions/2720014/how-to-upgrade-all-python-packages-with-pip) в pip. Вам придется буквально глазами отыскать ключевые зависимости в requirements.txt и выполнить для каждой `pip install package-name --upgrade`. Это не очень удобно. В качестве [обходного пути](https://kenreitz.org/essays/2016/02/25/a-better-pip-workflow) можно, например, использовать два файла requirements.txt (один с верхнеуровневыми зависимостями, другой с их зафиксированными версиями). При этом же не стоит забывать, что пакеты которые используются только для разработки, придется также указывать в списке зависимостей, или создавать еще один файл requirements.txt (requirements-dev.txt), но только для dev зависимостей. Однако, закрепляя все зависимости на конкретные версии разработчик несет ответственность за поддержание их актуальности. Что если в каком-то из пакетов обнаружен эксплоит? Вам необходимо самостоятельно следить за всеми этими пакетами, чтобы не пропустить уязвимость в вашем приложении, вызванную сторонним ПО.

Также к проблемам подхода pip + requirements.txt можно отнести тот факт, что файл зависимостей не обновляется самостоятельно. Например, вы у себя на машине добавили пакет, использовали его функционал в коде, и зафиксировали изменения. Если вы не вспомните, что пакет нужно закрепить в requirements.txt, ваш код будет нерабочим.  
Помимо этого, pip до версии 20.2 [не имел функционал разрешения зависимостей](https://github.com/pypa/pip/issues/6536), и в ситуации, когда два пакета внутри вашего проекта имеют одинаковую зависимость, он просто устанавливал первую найденную в списке, которая могла не подходить под нужды второго пакета.  
Кроме того, существует такая проблема, как [тайпсквоттинг](https://discuss.python.org/t/improving-risks-and-consequences-against-typosquatting-on-pypi/5090). Хранилище пакетов PyPI не модерируется пристально, любой человек может загрузить в него свой пакет. В связи с этим, некоторые злоупотребляют такой возможностью и [захватывают](https://pypi.org/user/russianidiot/) потенциально значимые названия пакетов или [создают клоны популярных](https://snyk.io/blog/malicious-packages-found-to-be-typo-squatting-in-pypi/) с именами частых опечаток, в которые в теории можно заложить вредоносный код.

Описанный выше набор проблем взялись решить сразу несколько проектов.


### [Pipenv](https://pipenv.pypa.io/en/latest/)
[Pipenv](https://github.com/pypa/pipenv) позиционирует себя как инструмент, который нацелен вобрать в себя лучшее из мира пакетных менеджеров ([bundler](https://bundler.io/), [composer](https://getcomposer.org/), [npm](https://www.npmjs.com/), [cargo](https://doc.rust-lang.org/cargo/), [yarn](https://yarnpkg.com/) и т.д.). Его преимущества:
1. Может автоматически создавать виртуальное окружение и управлять им - просто выполните `pipenv install package-name` и pipenv создаст виртуальное окружение в специальной директории. Если вы хотите создавать окружение в директории с проектом, [добавьте](https://pipenv.pypa.io/en/latest/install/#virtualenv-mapping-caveat) `export PIPENV_VENV_IN_PROJECT=1` в файл конфигурации вашей командной оболочки.
2. Может динамически добавлять/убирать пакеты в [Pipfile](https://pipenv.pypa.io/en/latest/basics/#example-pipfile) (аналог requirements.txt с синтаксисом [TOML](https://github.com/toml-lang/toml)), когда вы их устанавливаете/удаляете в окружении
2. Создает [Pipfile.lock](https://pipenv.pypa.io/en/latest/basics/#example-pipfile-lock), который содержит в себе конкретные версии всех установленных зависимостей с хешами, для создания точной копии рабочего окружения
3. Берет на себя заботу о возможных дырах в безопасности в куче пакетов отдельно, с помощью команды `pipenv check` произойдет поиск по базе известных уязвимостей, а также проверка на соответствие [PEP 508](https://www.python.org/dev/peps/pep-0508/)
4. Может отображать граф зависимостей с помощью команды `pipenv graph`
5. Может обновлять не только конкретный пакет - `pipenv update package-name`, но и все пакеты сразу - `pipenv update`
и много других полезных фишек, которые можно посмотреть в [официальной документации](https://pipenv.pypa.io/en/latest/).


### [poetry](https://python-poetry.org/docs/)
Утилита [poetry](https://github.com/python-poetry/poetry) также служит для решения описанных проблем подхода pip + requirements.txt, поэтому стоит сразу выделить ее отличия от Pipenv:
1. В качестве файла зависимостей она использует [pyproject.toml](https://python-poetry.org/docs/pyproject/), который описан в спецификации [PEP 518](https://www.python.org/dev/peps/pep-0518/) и был вдохновлен [package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json). Данный файл конфигурируется в интерактивном cli диалоге после вызова команды `poetry init`
2. poetry самостоятельно не умеет управлять версиями Python, а [делает это совместно с pyenv](https://python-poetry.org/docs/managing-environments/)
3. poetry имеет полноценный [механизм разрешения зависимостей](https://python-poetry.org/docs/faq/#why-is-the-dependency-resolution-process-slow)
4. Позволяет легко [собирать](https://python-poetry.org/docs/libraries/#packaging) `poetry build` и [публиковать](https://python-poetry.org/docs/libraries/#publishing-to-pypi) `poetry publish` пакеты

[Краткий бенчмарк Pipenv vs poetry](https://johnfraney.ca/posts/2019/03/06/pipenv-poetry-benchmarks-ergonomics/).


### [pyenv](https://github.com/pyenv/pyenv#readme)
Разбирая особенности poetry я вскользь упомянул такой инструмент, как [pyenv](https://github.com/pyenv/pyenv). История его появления простая - со временем Python развивался, его популярность росла, как и количество приложений написанных на нем. Интерпретатор включили в комплект поставки macOS и многих Linux дистрибутивов. Однако, не все приложения поспевали за развитием языка, да и не всем это требовалось, поэтому огромное количество кода до сих пор работает не только на ранних версиях 3.X, а в том числе и на 2.X, [поддержка которого завершена](https://www.python.org/doc/sunset-python-2/). Если для каждого из таких приложений ставить свой отдельный интерпретатор, то очень легко запутаться как в них самих, так и в их зависимостях. Именно эту проблему и решает утилита pyenv. Она сохраняет системную версию, которая отвечает за работу различных приложений, и позволяет установить на машине все возможные версии Python, которые будут изолированны друг от друга. Пользователь может на лету переключать версии интерпретатора, выставить и запомнить определенную для конкретного проекта, а также создавать виртуальные окружения с каждой из имеющихся версий.


### [pipx](https://pypa.github.io/pipx/) 
Существует еще такая утилита, как [pipx](https://github.com/pypa/pipx). Ее косвенно можно отнести к инструментам управления зависимостями Python. Основная задача pipx - работа с приложениями, чья входная точка это интерфейс командной строки. Она похожа на пакетные менеджеры [brew](https://brew.sh/index_ru), [npx](https://www.npmjs.com/package/npx) и [apt](https://tracker.debian.org/pkg/apt). Использует внутри себя pip, создает виртуальное окружение для приложения, добавляет необходимые данные в PATH, после чего приложение можно использовать напрямую в командной строке через CLI, а не как Python модуль. В официцальной документации есть [сравнение с остальными утилитами](https://pypa.github.io/pipx/comparisons/). 


### Вывод
Как видим, современный Python имеет несколько инструментов управления зависимостями, которые в целом весьма похожи между собой. Выделить какой-то единый и самый лучший довольно сложно, самый оптимальный вариант - это поработать немного со всеми и выбрать тот, который вам больше нравится и наиболее оптимально помогает решать задачи. Лично я на данный момент остановился на [варианте pyenv]({% link _posts/2022-04-05-python-with-pyenv.markdown %}) + poetry.

---
Источники:
1. [Overview of python dependency management tools](https://modelpredict.com/python-dependency-management-tools)
2. [Pipenv: A Guide to the New Python Packaging Tool](https://realpython.com/pipenv-guide/)
3. [Managing Multiple Python Versions With pyenv](https://realpython.com/intro-to-pyenv/)
