---
layout: post
title:  Управление зависимостями Python в 2021
date:   2021-07-08 10:00:00 +0300
categories: python
---

Современный Python имеет множество пакетов, помогающих разработчику в решении задач, а также большое количество инструментов, которые с этими пакетами работают. https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe
Представим ситуацию, когда у вас есть два проекта, внутри которых необходимо использовать pytest. В одном из них вам нужен pytest версии 3.x, а в другой - pytest 6.x. Между собой они не имеют обратной совместимости. Глобально интерпретатор в состоянии иметь только одну версию пакета. Как быть в данном случае? Решить эту проблему помогает такой инструмент, как виртуальное окружение. Виртуальное окружение - это изолированная копия Python, которая не видит пакеты, доступные системному интерпретатору, и наоборот.

Как создать виртуальное окружение? Начиная с версии Python 3.3 в стандартной библиотеке есть модуль venv https://docs.python.org/3/library/venv.html
python -m venv path/to/your-venv
создает виртуальное окружение your-venv по указаннному пути.
Активируем это окружение
Unix
source venv-name/bin/activate 
Windows
venv-name/Scripts/activate.bat
В окне терминала появилась приписка об используемом виртуальном окружении. Теперь у вас есть изолированная Python среда, в которую вы можете ставить любые интересующие вас пакеты, не боясь создать коллизий и нарушить работу остальных Python проектов.

Если вы хотите использовать virtualenv, его нужно сначала установить, т.к. это сторонний пакет. Делается это командой:
pip install virtualenv
Команда
python -m virtualenv path/to/your-venv
создает виртуальное окружение в текущей директории. 

В чем же разница между venv и virtualenv, ведь на первый взгяд они делают одно и то же? venv по сути можно назвать подмножеством пакета virtualenv, т.е. его сокращенной версией. По информации из официальной документации по virtualenv, venv имеет ряд минусов: https://virtualenv.pypa.io/en/stable/
1. медленнее, т.к. virtualenv использует метод app-data seed (единожды при первом использовании создает пакеты pip, setuptools, wheel, а при последующих вызовах просто копирует или линкует их) https://virtualenv.pypa.io/en/latest/user_guide.html#seeders
2. не расширяем, не имеет богатого API
3. создает окружение только для своей версии Python
4. обновляется только вместе с Python интерпретатором, в том время как virtualenv обновляется через pip
В целом, эти минусы не критичные, поэтому если вы по какой-то причине не хотите ставить сторонний пакет, можно использовать встроенный в стандартную библиотеку модуль venv. Однако, большинство систем управления зависимостями (если не все, кроме pip), имееют уже в своих зависимостях virtualenv, поэтому при их использовании он у вас в системе появится.


Кстати об установке пакетов, давайте рассмотрим ее подробнее.

pip
Package Installer for Python - это базовый инструмент взаимодействия с пакетами в Python. С его помощью можно устанавливать конкретные версии пакетов. По умолчанию он ищет пакеты в PyPI (Python Package Index), но с помощью различных опций команд (--index-url=URL, --trusted-host=HOST) позволяет искать пакеты и в других хранилищах.
pip install package-name
попытается найти пакет package-name в PyPI, и если обнаружит его, установит самую последнюю версию и связанные с ней зависимости. 
pip позволяет фиксировать зависимости приложения в файле requirements.txt
pip freeze > requirements.txt
А также установить зафиксированные в нем зависимости себе в окружение с помощью
pip install -r requirements.txt

Работа с requirements.txt обычно имеет два подхода:
метод 1 - фиксация только верхнеуровневых пакетов
метод 2 - фиксация верхнеуровневых пакетов и всех зависимостей
Однако оба подхода имееют под собой набор недостатков. 

Метод 1 - когда зафиксированы только верхнеуровневые пакеты - не может гарантировать, что сборка на другом окружении будет в точности той же. Например, вы работаете над Python проектом, который использует Flask. Вы включаете пакет в requirements.txt, чтобы остальные разработчики и система автоматизации сборки могли запустить ваш проект. 
code requirements.txt
flask
Локально все запускается, как задумано, и после работ над проектом вы решаете опубликовать изменения на production окружении. Если пакет зафиксирован без указания версии, то pip по умолчанию скачивает самую последнюю, в которой может появится изменение, не имеющее обратной совместимости с вашим кодом. Можно зафиксировать версию пакета, вот так:
code requirements.txt
flask==1.1.2
Однако у Flask есть и свои зависимости, которые, как и у многих других пакетов, часто тоже не зафиксированы на конкретные версии, например Flask v1.1.2 может иметь в зависимостях Werkzeug>=0.15.5, а значит поставится тоже самая последняя версия, в которой, опять же, может появиться функционал, нарушающий работу приложения. 

Метод 2 - когда зафиксированы все пакеты и их зависимости - является общепринятой практикой. Но и она не без недостатков. Обновить все пакеты до последних версий не выйдет, такой команды просто нет в pip https://stackoverflow.com/questions/2720014/how-to-upgrade-all-python-packages-with-pip. Вам придется буквально глазами отыскать ключевые зависимости в requirements.txt и выполнить pip install package-name --upgrade. Это не очень удобно. В качестве возможного обходного пути можно использовать два файла requirements https://kenreitz.org/essays/2016/02/25/a-better-pip-workflow (один с верхнеуровневыми зависимостями, другой с их freeze версиями). К тому же, закрепляя все зависимости на конкретные версии разработчик несет ответственность за поддержание их актуальности. Что если в каком-то из пакетов обнаружен эксплоит? Вам необходимо самостоятельно следить за всеми этими пакетами, чтобы не допустить зловредных действий. 

Также к проблемам pip можно отнести тот факт, что он не обновляется самостоятельно (вы что-то сделали, поставили себе пакет, но забыли зафиксировать это в файле). Тайпсквоттинг - PyPI не модерируется. К тому же, до 2020 года, pip не имел встроенного функционал разрешения зависимостей.

О pip можно больше узнать подробно в документации или кратко с помощью pip --help.


https://realpython.com/pipenv-guide/
pipenv
Это пакет управления зависимостями и виртуальным окружением для Python, который вызвался решить проблемы, связанные с рабочим процессом, который основан на pip, virtualenv и requirements.txt.

pyenv
Со временем питон развивался, его популярность росла, как и количество приложений написанных на нем. Интерпретатор включили в комплект поставки многих Linux дистрибутивов, mac OS. Однако, не все приложения поспевали за развитием языка, поэтому огромное количество кода до сих пор работает не только на питон 3.X, а в том числе и на 2.X. Если для каждого из проекта ставить свой отдельный интерпретатор, то очень легко запутаться как в них самих, так и в их зависимостях. Решить эту проблему пробует утилита pyenv. Она сохраняет системную версию, которая отвечает за работу различных приложений, и позволяет изоляция их друг от друга и работа с виртуальными окружениями. Пользователь может на лету переключать версии интерпретатора, а благодаря различным плагинам для командных оболочек, позволяющим, например, активировать виртуальную среду по входу в директорию, работа с утилитой сильно упрощает жизнь разработчику.

potry

direnv ?